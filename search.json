[{"title":"[object Object]","url":"/2024/09/13/详解AOP的实现（五种增强方式）及执行流程/","content":"@[toc]\n#  AOP的简单介绍\nAOP（Aspect Oriented Programming 面向切面编程）是一种通过运行期动态代理实现代码复用的机制，是对传统OOP(Object Oriented Programming，面向对象编程 )的补充。目前，Aspectj是Java社区里最完整最流行的AOP框架，在Spring 2.0以上版本中可以通过Aspectj注解或基于XML配置AOP。\n#  建立AOP实例工程\n##  工程结构如下图所示\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019071614023511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfZGFfYmluZw==,size_16,color_FFFFFF,t_70)\n**ICalculatorService的源码如下：**\n```java\npackage com.jd.calculator;\npublic interface ICalculatorService {\n\tint mul(int a, int b);\t\t\n    int div(int a, int b) ;\n}\n```\n**CalculatorService的源码如下：**\n```java\npackage com.jd.calculator.imp;\nimport org.springframework.stereotype.Service;\nimport com.jd.calculator.ICalculatorService;\n@Service\npublic class CalculatorService implements ICalculatorService{\n\t@Override\n\tpublic int mul(int a, int b) {\n\t\tint result = a*b;\n\t\tif(result == 0) {\n\t\t\tthrow new ArithmeticException(\"两数之积不能为零\");\n\t\t}\n\t\treturn result;\n\t}\n\t@Override\n\tpublic int div(int a, int b) {\n\t\tint result = a/b;\n\t\treturn result;\n\t}\n}\n```\n**CalculatorAspect的源码如下：**\n```java\npackage com.jd.calculator.imp;\n\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.springframework.stereotype.Component;\n@Aspect\n@Component\npublic class CalculatorAspect {\n\t@Pointcut(\"execution(int mul(int ,int))\")//进一步实现代码重用（注解属性的重用）空方法上加入pointcut注解即可\n\tpublic void pointCut () {\t\t\n\t}\n\t@Before(\"pointCut ()\")\n\tpublic void before(JoinPoint jp) {\n\t\tObject object = jp.getTarget();\n\t\tObject [] args = jp.getArgs();\n\t\tString methodName = jp.getSignature().getName();\n\t\tSystem.out.println(object.getClass().getName()+\"：The \"+methodName+\" method begins.\");\n\t\tSystem.out.println(object.getClass().getName()+\"：Parameters of the \"+methodName+\" method： [\"+args[0]+\",\"+args[1]+\"]\");\t\t\n\t}\n\t@After(\"pointCut ()\")\n\tpublic void after(JoinPoint jp) {\n\t\tObject object = jp.getTarget();\n\t\tString methodName = jp.getSignature().getName();\n\t\tSystem.out.println(object.getClass().getName()+\"：The \"+methodName+\" method ends.\");\n\t}\n\t@AfterReturning(value = \"execution(int mul(int ,int))\", returning = \"result\")\n\tpublic void returnAfter(JoinPoint jp , Object result) {\n\t\tObject object = jp.getTarget();\n\t\tString methodName = jp.getSignature().getName();\n\t\tSystem.out.println(object.getClass().getName()+\"：Result of the \"+methodName+\" method：\"+result);\n\t}\n\t@AfterThrowing(value=\"execution(int mul(int ,int))\", throwing= \"e\")\n\tpublic void afterThrowing (JoinPoint jp, NullPointerException e) {\n\t\tObject object = jp.getTarget();\n\t\tString methodName = jp.getSignature().getName();\n\t\tSystem.out.println(object.getClass().getName()+\"：Result of the \"+methodName+\" method：\"+e.getMessage());\n\t}\n}\n```\n> 注;环绕增强的代码如下：\n\n```java\n\t@Around(\"pointCut()\")\n\tpublic Object process (ProceedingJoinPoint pjp) {\n\t\tObject result=null;\n\t\tObject[] args = pjp.getArgs();\n\t\tObject object = pjp.getTarget();\n\t\tString methodName = pjp.getSignature().getName();\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tSystem.out.println(object.getClass().getName() + \"：The \" + methodName + \" method begins.\");\n\t\t\t\tSystem.out.println(object.getClass().getName() + \"：Parameters of the \" + methodName + \" method： [\"\n\t\t\t\t\t\t+ args[0] + \",\" + args[1] + \"]\");\n\t\t\t\tresult = pjp.proceed();//执行目标方法\n\t\t\t} finally {\n\t\t\t\tSystem.out.println(object.getClass().getName()+\"：The \"+methodName+\" method ends.\");\n\t\t\t}\n\t\t} catch (Throwable e) {\n\t\t\tSystem.out.println(object.getClass().getName()+\"：Result of the \"+methodName+\" method：\"+e.getMessage());\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n```\n\n**Test源码如下：**\n```java\npackage com.jd.test;\n\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\nimport com.jd.calculator.ICalculatorService;\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\t@SuppressWarnings(\"resource\")\n\t\t//获取管理Bean的IOC容器\n\t\tClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"application.xml\");\n\t\t//获取容器中相关的类,符合条件，设置动态代理类\n\t\tICalculatorService calculatorService = applicationContext.getBean(ICalculatorService.class);\n\t\tint result = calculatorService.mul(1, 2);\n\t\tSystem.out.println(\"---->\" + result);\n\t\tapplicationContext.close();//关闭容器\n\t}\n}\n```\n**application.xml的源码如下：**\n```java\n<beans>\n\t<context:component-scan base-package=\"com.jd\"></context:component-scan>\n\t<aop:aspectj-autoproxy proxy-target-class=\"false\"></aop:aspectj-autoproxy>\n</beans>\n```\n##  代码注解释义\n1. @Aspect：将该类声明为切面类\n2. @Component与@Service：将该类对象放入IOC容器\n3. @Before(\"execution(public int com.jd.calculator.CalculatorService.*(..))\")：前置增强（又称前置通知）即在目标方法执行之前执。\n4. @After(\"execution(public int com.jd.calculator.CalculatorService.*(..))\")：后置增强（又称后置通知）：在目标方法执行后执行，无论目标方法运行期间是否出现异常。注意：后置增强无法获取目标方法执行结果，可以在返回增强中获取。\n5. @AfterReturning(value = \"execution(int mul(int ,int))\", returning = \"result\")：返回增强（又称返回通知）：在目标方法正常结束后执行，可以获取目标方法的执行结果。\n>  注：返回增强的方法的参数名必须与注解属性returning的值相同\n\n6. @AfterThrowing(value=\"execution(int mul(int ,int))\", throwing= \"e\")：//异常增强（又称异常通知）：目标方法抛出异常之后执行，可以访问到异常对象，且可以指定在出现哪种异常时才执行增强代码。\n>  注：1. 当目标方法抛出的异常与增强方法中的异常不满足继承关系时（增强方法中的异常必须为目标方法中的异常的父类），则异常增强不会触发。\n>  2. 上例中如果传入实参为0，和1，触发异常，但不会进行异常增强（ArithmeticException和NullPointerException不为继承关系） \n> 3.  @Before、@After、@AfterRunning和@AfterThrowing修饰的方法可以通过声明JoinPoint 类型参数变量获取目标方法的信息（方法名、参数列表等信息）；@Around修饰的方法必须声明ProceedingJoinPoint类型的参数，该变量可以决定是否执行目标方法；\n> 4. @Before,@After,@AfterReturning,@AfterThrowing执行顺序执行过程\n>  \n>  ···java\n>  try {\n>  \ttry {\n>  \t\tdoBefore();// @Before注解所修饰的方法\n>  \t\tmethod.invoke();// 执行目标对象内的方法\n>  \t} finally {\n>  \t\tdoAfter();// @After注解所修饰的方法\n>  \t}\n>  \tdoAfterReturning();// @AfterReturning注解所修饰的方法\n>      } catch (Exception e) {\n>      \tdoAfterThrowing();// @AfterThrowing注解所修饰的方法\n>    }\n\n7. @Pointcut(\"execution(int mul(int ,int))\")：进一步实现代码重用（注解属性的重用）空方法上加入pointcut注解即可，即在方法的注解属性中配置pointCut ()即可实现execution(int mul(int ,int)的功能。\n8. @Around(\"execution(public int com.jd.calculator.CalculatorService.*(..))\"):环绕增强：目标方法执行前后都可以织入增强处理.\n>  注：1. @Around修饰的方法必须声明ProceedingJoinPoint类型的参数，该变量可以决定是否执行目标方法；\n>  2. @Before、@After、@AfterRunning和@AfterThrowing修饰的方法没有返回值；而@Around修饰的方法必须有返回值，返回值为目标方法的返回值；\n\n\n##  application.xml配置文件释义\n```java\n<context:component-scan base-package=\"com.jd\"></context:component-scan>\n```\n> 注：扫描com.jd包下的所有类，根据注解创建对象，放在IOC容器中。\n\n```java\n<aop:aspectj-autoproxy proxy-target-class=\"false\"></aop:aspectj-autoproxy>\n```\n>  配置自动代理，proxy-target-class=\"false\"：默认为false:即设置代理为jdk动态代理，若改为true，则  设置代理为cglib动态代理\n>Spring的jar包已经包括了cglib的asm和cglib的jar包，所以不需要引入这两个包即可使用cglib动态代理。\n##  AOP 的执行流程\n```java\n<aop:aspectj-autoproxy proxy-target-class=\"false\"></aop:aspectj-autoproxy>\n```\n在执行以上配置时：找到Aspect注解的类（CalculatorAspect）-->找到类中注解的方法获取注解属性值（@Before(\"execution(int mul(int ,int))\")）-->扫描所有类及类中方法-->找到符合注解属性的方法-->为该方法的类设置动态代理\n> 注：1. 可有通过IOC容器获取该动态代理。applicationContext.getBean(ICalculatorService.class);\n>2. 获取动态代理类时传入ICalculatorService.class，而不是CalculatorService.class是因为AOP默认采用jdk的动态代理（采用的是继承机制），而目标类CalculatorService.class与jdk动态代理 类不满足继承关系。\n>3. 若配置文件中配置proxy-target-class=\"true\"，则获取动态代理类时传入ICalculatorService.class\n或CalculatorService.class都可以，原因是该配置修改AOP的动态代理为cglib动态代理（采用继承机制），动态代理类与这两个类都存在继承关系。\n##  通过xml文件配置AOP\n**xml文件源码及配置释义如下：**\n```javva\n   <context:component-scan base-package=\"com.jd\"></context:component-scan>\n   <!--创建PalculatorAspect和CalculatorAspec的对象-->\n\t<bean class=\"com.jd.calculator.imp.PalculatorAspect\" id = \"PalculatorAspect\"></bean>\n\t<bean class=\"com.jd.calculator.imp.CalculatorAspect\" id = \"CalculatorAspect\"></bean>\n\t<!--配置AOP,proxy-target-class=\"false“设置动态代理的方式”-->\n\t<aop:config proxy-target-class=\"false\">\n\t\t<!--aspect ref=\"PalculatorAspect\"设置Aspect注解类， order=\"2\"设置优先级->\n\t\t<aop:aspect ref=\"PalculatorAspect\" order=\"2\">\n\t\t\t<!--pointcut=\"execution(int mul(int ,int))设置注解属性-->\n\t\t\t<aop:before method=\"before\" pointcut=\"execution(int mul(int ,int))\"/>\n\t\t</aop:aspect>\n\t\t<aop:aspect ref=\"CalculatorAspect\" order=\"1\">\n\t\t\t<aop:before method=\"before\" pointcut=\"execution(int mul(int ,int))\"/>\n\t\t</aop:aspect>\n\t</aop:config>\n```\n> PalculatorAspec和CalculatorAspec都对目标方法进行了前置加强\n\n##  AOP中相关概念释义\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190717122638133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfZGFfYmluZw==,size_16,color_FFFFFF,t_70)\n##  切入点通配符详解\n\nSpring AOP支持如下三种通配符：\n1. *：匹配任何数量字符，用于参数列表表示参数可以是任意数据类型，但是必须有参数，例子：\njava.*.Date——>匹配java包的下一级子包中的任何Date类型；如匹配java.util.Date、java.sql.Date，但不匹配java.util.sql.Date；\njava.lang.*e——>匹配任何java.lang包下的以e结尾的类型，如匹配java.util.Hashtable、java.util.Date等等；\n\n2. ..：方法中表示任意数量参数，在包中表示当前包及其子包，例子：\njava..*——>匹配java包及其任何子包下的任何类型，如匹配java.lang.String、java.lang.annotation.Annotation等等；\n\n3. +：匹配指定类型的子类型（不是子类）；仅能作为后缀放在类型模式后边，例子：\njava.lang.Number+——>匹配java.lang包下任何Number的子类型，如匹配java.lang.Integer、java.math.BigInteger等等；\njava.util.List+——>匹配java.util.List接口实现类，如匹配java.util.ArrayList，但不匹配java.util.HashMap\n\n> 注：execution切入点表达式的语法： \n语法：\nexecution([修饰符] 返回值类型 [包名.类名/接口名.]方法名([参数])[异常])，\n说明：\na、该表达式用于指定匹配的方法；\nb、修饰符包括访问权限和static、final以及synchronized；\nc、红色中括号框起的部分可以省略。\n\n","tags":["Java"],"categories":["Coding"]},{"title":"Hello World","url":"/2024/09/02/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]